import OpenAI from 'openai';
import { StatusCodes } from 'http-status-codes';
import { NotificationService } from './notification.services';
import catchAsync from '../../shared/catchAsync';
import pick from '../../shared/pick';
import sendResponse from '../../shared/sendResponse';
import { notificationFilters } from './notification.constants';
import { differenceInDays } from 'date-fns';
import { FertieService } from '../fertie/fertie.service';
import { Notification } from './notification.model';
import sendPushNotification from '../../utils/sendPushNotification'
import { PersonalizeJourney } from '../_personalizeJourney/personalizeJourney/personalizeJourney.model';
import { User } from '../user/user.model';
const model = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY, //OPENAI_API_KEY // OPENROUTER_API_KEY
  // baseURL: 'https://openrouter.ai/api/v1',
  baseURL: 'https://api.openai.com/v1'
});

const getALLNotification = catchAsync(async (req, res) => {
  const filters = pick(req.query, notificationFilters);
  const options = pick(req.query, ['sortBy', 'limit', 'page', 'populate']);
  const userId = req.user.userId;
  const result = await NotificationService.getALLNotification(
    filters,
    options,
    userId
  );
  sendResponse(res, {
    code: StatusCodes.OK,
    data: result,
    message: 'Notifications fetched successfully',
    success: true,
  });
});

//-------------- TODO : must check this function is working or not ..
const getAllNotificationAlongWithTodaysNotificationGeneratedByChatGpt = catchAsync(
  async (req, res) => {

    // const generateTodaysNotification = await NotificationService.sendNotificationByChatGpt(req.user.userId);
    // Get the current date
    const currentDate = new Date();

    let notificationFromDbForToday = await Notification.find({
      receiverId: req.user.userId,
      createdAt: {
        $gte: new Date(currentDate.setHours(0, 0, 0, 0)),
        $lt: new Date(currentDate.setHours(23, 59, 59, 999)),
      },
    })


    if (notificationFromDbForToday.length > 0) {
      console.log('Todays notification already generated by chatgpt');


      if(notificationFromDbForToday.length < 2){
          let newAIGeneratedNotification = await Notification.create({
              title: 'Hey! Donâ€™t forget to check your cycle insights today!',
              subTitle: 'Remainder',
              receiverId: req.user.userId,
          })

          /****************************************
  
          await sendPushNotification(req.user.fcmToken, {
            title: 'Hey! Donâ€™t forget to check your cycle insights today!',
            content: 'Remainder',
          }); 

           *********************************** */
          
      }

      let allNotifications = await Notification.find({
        receiverId: req.user.userId,
      }).updateMany(
        { $set: { viewStatus : true } },
        { new: true }
      )
      
      sendResponse(res, {
        code: StatusCodes.OK,
        data: allNotifications,
        message: 'Todays notification already generated by chatgpt',
        success: true,
      });

      return;
    }

    /************
     * 
     * No notification found for today, so we will generate it using chatgpt
     * 
     * ************** */

    // first we need to get the users current months all information .. 
    // like âš¡predictedPeriodStart âš¡ predictedPeriodEnd
    // âš¡ predictedOvulationDate âš¡ fertileWindow

    let data:any = await new FertieService().predictAllDates(req.user.userId);

    //  const [year, month] = req.body.date.split('-');
     const [year, month] = new Date().toISOString().split('T')[0].split('-');
    const targetYearMonth = `${year}-${month}`;

    // Find the month object that matches the target year-month
    const monthData = data.find(item => item.month === targetYearMonth);

    if (!monthData) {
      console.error(`No data found for month: ${targetYearMonth}`);
      return;
    }

    // Extract period start date for the found month
    const periodEvent : {
      predictedPeriodStart: Date;
      predictedPeriodEnd: Date;
      predictedOvulationDate: Date;
      fertileWindow: [Date, Date];
    } = monthData.events.find(event => event.predictedPeriodStart);
  
    console.log('periodEvent :::::::::::: ', periodEvent);

    
    const periodStartDate = periodEvent.predictedPeriodStart//.split('T')[0];

    const user = await User.findById(req.user.userId).select(
      'personalize_Journey_Id'
    );
    if (!user) {
      console.error('User not found');
      return;
    }

    const journey = await PersonalizeJourney.findById(
            user?.personalize_Journey_Id
    );

    console.log('journey ðŸ”¥', journey);

    if (!journey) return;


    const { avgMenstrualCycleLength } =
        journey;

    const today = new Date();
    const baseDate = new Date(periodStartDate);

    let cycleDay = calculateCurrentCycleDay(
        today,
        baseDate,
        Number(avgMenstrualCycleLength)
    );
    /**
     * now we have information like 
     * periodEvent {
     *   predictedPeriodStart
     *   predictedPeriodEnd
     *   predictedOvulationDate 
     *   fertileWindow [ Date , Date ]
     * }
     * 
     * and cycleDay .. 
     */

    // Build system prompt
    const systemPrompt = `You are a friendly reproductive health assistant Named Fertie.
      Based on current months different dates like predictedPeriodStart, predictedPeriodEnd, 
      predictedOvulationDate, fertileWindow, cycleDay
      provide notification if current date matched with any of those date.

      Data available: 

      - PeriodStartDate: ${periodEvent.predictedPeriodStart || 'N/A'}
      - PeriodEndDate: ${periodEvent.predictedPeriodEnd || 'N/A'}
      - predictedOvulationDate: ${periodEvent.predictedOvulationDate || 'N/A'}
      - fertileWindow: ${periodEvent.fertileWindow || 'N/A'}
      - cycleDay: ${cycleDay || 'N/A'}
      - currentDate: ${currentDate || 'N/A'} 

      -------------- Now generate notification title and subtitle .. if current date matched with any of those date --------------
  
      ---------------------------
      if any date matched give me notification response like {
        "title" : "notification title here!",
        "subTitle" : "notification subTitle here!",
      }

      -------------------------
      if no date matched give me response like {
        "title" : "Hey! Donâ€™t forget to check your cycle insights today!",
        "subTitle" : "Remainder",
      }
    `;
    ////////////////////////////////////////////////////

    // Initialize response string
        let responseText = '';
    
        // Retry logic for API rate limits
        const maxRetries = 3;
        let retries = 0;
        let delay = 1000; // Start with 1 second delay
        let stream;
    
        while (retries <= maxRetries) {
          try {
            stream = await model.chat.completions.create({
              model: 'gpt-4o', // qwen/qwen3-30b-a3b:free <- is give wrong result   // gpt-3.5-turbo <- give perfect result
              messages: [
                { role: 'system', content: systemPrompt },
                // { role: 'user', content: userMessage },
              ],
              temperature: 0.7,
              stream: true,
            });
    
            // If we get here, the request was successful
            break;
          } catch (error) {
            // Check if it's a rate limit error (429)
            if (error.status === 429) {
              if (
                error.message &&
                (error.message.includes('quota') ||
                  error.message.includes('billing'))
              ) {
                // This is a quota/billing issue - try fallback if we haven't already
                if (retries === 0) {
                  console.log('Quota or billing issue. Trying fallback model...');
                  try {
                    // Try a different model as fallback
                    stream = await model.chat.completions.create({
                      model: 'gpt-3.5-turbo', // Using the same model as a placeholder, replace with actual fallback
                      messages: [
                        { role: 'system', content: systemPrompt },
                        // { role: 'user', content: userMessage },
                      ],
                      temperature: 0.7,
                      stream: true,
                    });
                    break; // If fallback succeeds, exit the retry loop
                  } catch (fallbackError) {
                    console.error('Fallback model failed:', fallbackError);
                    // Continue with retries
                  }
                } else {
                  console.log(
                    'Quota or billing issue. No more fallbacks available.'
                  );
                  throw error; // Give up after fallback attempts
                }
              }
    
              // Regular rate limit - apply exponential backoff
              retries++;
              if (retries > maxRetries) {
                // Send error message to client before throwing
                res.write(
                  `data: ${JSON.stringify({
                    error: 'Rate limit exceeded. Please try again later.',
                  })}\n\n`
                );
                res.end();
                throw error; // Give up after max retries
              }
    
              console.log(
                `Rate limited. Retrying in ${delay}ms... (Attempt ${retries}/${maxRetries})`
              );
              await new Promise(resolve => setTimeout(resolve, delay));
    
              // Exponential backoff with jitter
              delay = delay * 2 * (0.5 + Math.random()); // Multiply by random factor between 1 and 1.5
            } else {
              // Not a rate limit error
              console.error('OpenAI API error:', error);
              res.write(
                `data: ${JSON.stringify({
                  error: 'An error occurred while processing your request.',
                })}\n\n`
              );
              res.end();
              return; // Exit the function
            }
          }
        }
    
        if (!stream) {
          res.write(
            `data: ${JSON.stringify({
              error: 'Failed to generate a response. Please try again.',
            })}\n\n`
          );
          res.end();
          return;
        }
    
        try {
            // Process each chunk as it arrives
     
          for await (const chunk of stream) {
            const content = chunk.choices[0]?.delta?.content || '';
            if (content) {
              responseText += content;
            }
          }
    
          // Parse the JSON string into an object
          let newAIGeneratedNotification;
          let allNotificaiton;
          let jsonResponse;
          try {
            // First, try to parse the response directly
            jsonResponse = JSON.parse(responseText);

            //-------------- we have to save this response to notification database .. 
                // and first we have to check if todays notification already generated or not
                // and if todays notification is not found in database .. then ai will generate new notification
                // for today and save it to database ..


            console.log("ðŸŸ¢ No AI Generated Notification found for today ... Lets generate ... ðŸ¤–");

            newAIGeneratedNotification = await Notification.create({
              title: jsonResponse.title,
              subTitle: jsonResponse.subTitle,
              receiverId: req.user.userId,
            })

            /*************************************
             
            await sendPushNotification(req.user.fcmToken, {
              title: jsonResponse.title,
              content: jsonResponse.subTitle,
            });

             *********************************** */

            allNotificaiton = await Notification.find({
              receiverId: req.user.userId,
            }).sort({ createdAt: -1 }) // sort by createdAt descending
            .limit(10);

            console.log("jsonResponse ðŸŸ¢ðŸŸ¢ðŸŸ¢ :", jsonResponse);
          } catch (parseError) {
            // If direct parsing fails, try to extract JSON from the response
            console.log("Failed to parse direct response, attempting to extract JSON");
            
            // Try to extract JSON using regex
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              try {
                // ---------------------------------------------------------------------------------
                jsonResponse = JSON.parse(jsonMatch[0]); 

                //-------------- we have to save this response to notification database .. 
                // and first we have to check if todays notification already generated or not
                // and if todays notification is not found in database .. then ai will generate new notification
                // for today and save it to database ..


                console.log("ðŸŸ¢ No AI Generated Notification found for today ... Lets generate ... ðŸ¤–");

                newAIGeneratedNotification = await Notification.create({
                  title: jsonResponse.title,
                  subTitle: jsonResponse.subTitle,
                  receiverId: req.user.userId,
                })

                allNotificaiton = await Notification.find({
                  receiverId: req.user.userId,
                }).sort({ createdAt: -1 }) // sort by createdAt descending
                .limit(10);


                console.log("jsonResponse ðŸŸ¢ðŸŸ¢ðŸŸ¢ :", jsonResponse);

                //----------------------------------------------------------------------------------
              } catch (extractError) {
                console.error('Failed to extract valid JSON:', extractError);
                jsonResponse = {
                  suggestion: "Failed to parse AI response. Please try again.",
                };
              }
            } else {
              // Fallback to a structured response if parsing fails
              jsonResponse = {
                suggestion: responseText.substring(0, 200) + "...",
                patternFertieNoticed: "Unable to parse the complete response",
                whatToKeepInMindInThisCycle: "Please try again later"
              };
            }
          }
         
          // Send end of stream marker
          // res.write(`data: ${JSON.stringify({ done: true, fullResponse: responseText })}\n\n `); // ðŸŸ¢
    
          sendResponse(res, {
            code: StatusCodes.OK,
            // jsonResponse,newAIGeneratedNotification,
             data: {jsonResponse,newAIGeneratedNotification, allNotificaiton} ,  //   jsonResponse  //session.url,
            //data: allNotificaiton ,
            message: `Notification generated successfully..`,
            success: true,
          });
    
          /**
           *
           * save bots response in the database ..
           */
    
          res.end(); // ðŸŸ¢ðŸŸ¢ðŸŸ¢ end korte hobe
        } catch (streamError) {
          console.error('Error processing stream:', streamError);
          res.write(
            `data: ${JSON.stringify({
              error: 'Stream processing error. Please try again.',
            })}\n\n`
          );
          res.end();
        }
  })

/*
const getAdminNotifications = catchAsync(async (req, res) => {
  const filters = pick(req.query, notificationFilters);
  const options = pick(req.query, ['sortBy', 'limit', 'page', 'populate']);
  const result = await NotificationService.getAdminNotifications(
    filters,
    options
  );
  sendResponse(res, {
    code: StatusCodes.OK,
    data: result,
    message: 'Admin Notifications fetched successfully',
  });
});

const getSingleNotification = catchAsync(async (req, res) => {
  const { id } = req.params;
  const result = await NotificationService.getSingleNotification(id);
  sendResponse(res, {
    code: StatusCodes.OK,
    data: result,
    message: 'Notification fetched successfully',
    success: true,
  });
});

const viewNotification = catchAsync(async (req, res) => {
  const { id } = req.params;
  const result = await NotificationService.viewNotification(id);
  sendResponse(res, {
    code: StatusCodes.OK,
    data: result,
    message: 'Notification viewed successfully',
    success: true,
  });
});

const deleteNotification = catchAsync(async (req, res) => {
  const { id } = req.params;
  await NotificationService.deleteNotification(id);
  sendResponse(res, {
    code: StatusCodes.OK,
    message: 'Notification deleted successfully',
    success: true,
    data: {},
  });
});

const clearAllNotification = catchAsync(async (req, res) => {
  const userId = req.user.userId;
  await NotificationService.clearAllNotification(userId);
  sendResponse(res, {
    code: StatusCodes.OK,
    message: 'All notifications cleared successfully',
    success: true,
    data: {},
  });
});

*/

export const NotificationController = {
  getALLNotification,
  getAllNotificationAlongWithTodaysNotificationGeneratedByChatGpt
  // getAdminNotifications,
  // getSingleNotification,
  // viewNotification,
  // deleteNotification,
  // clearAllNotification,
};

// Helper function to calculate current cycle day
function calculateCurrentCycleDay(
  currentDate: Date,
  baseDate: Date,
  avgCycleLength: number
): number {
  const daysSinceBase = Math.floor(
    (currentDate.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24)
  );

  if (daysSinceBase < 0) {
    // Current date is before the base date
    return 1;
  }

  // Calculate which cycle we're in and what day of that cycle
  const cycleDay = (daysSinceBase % avgCycleLength) + 1;

  return cycleDay;
}
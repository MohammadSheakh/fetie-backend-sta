import OpenAI from 'openai';
import { StatusCodes } from 'http-status-codes';
import { NotificationService } from './notification.services';
import catchAsync from '../../shared/catchAsync';
import pick from '../../shared/pick';
import sendResponse from '../../shared/sendResponse';
import { notificationFilters } from './notification.constants';
import { differenceInDays } from 'date-fns';
import { FertieService } from '../fertie/fertie.service';
import { Notification } from './notification.model';
import sendPushNotification from '../../utils/sendPushNotification'
import { PersonalizeJourney } from '../_personalizeJourney/personalizeJourney/personalizeJourney.model';
import { User } from '../user/user.model';
const model = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY, //OPENAI_API_KEY // OPENROUTER_API_KEY
  // baseURL: 'https://openrouter.ai/api/v1',
  baseURL: 'https://api.openai.com/v1'
});

const getALLNotification = catchAsync(async (req, res) => {
  const filters = pick(req.query, notificationFilters);
  const options = pick(req.query, ['sortBy', 'limit', 'page', 'populate']);
  const userId = req.user.userId;
  const result = await NotificationService.getALLNotification(
    filters,
    options,
    userId
  );
  sendResponse(res, {
    code: StatusCodes.OK,
    data: result,
    message: 'Notifications fetched successfully',
    success: true,
  });
});

/*********
 * 
 * Testing This Function ... 17/8/2025 ..  Time 10:13 AM
 * 
 * ******** */
//-------------- TODO : must check this function is working or not ..
const getAllNotificationAlongWithTodaysNotificationGeneratedByChatGpt = catchAsync(
  async (req, res) => {

    // const generateTodaysNotification = await NotificationService.sendNotificationByChatGpt(req.user.userId);
    // Get the current date
    const currentDate = new Date();

    console.log("currentDate ðŸ”Š", currentDate);

    let notificationFromDbForToday = await Notification.find({
      receiverId: req.user.userId,
      createdAt: {
        $gte: new Date(currentDate.setHours(0, 0, 0, 0)),
        $lt: new Date(currentDate.setHours(23, 59, 59, 999)),
      },
    })

    console.log("notificationFromDbForToday ðŸ”Š", notificationFromDbForToday);

    if (notificationFromDbForToday.length > 0) {
      console.log('Todays notification already generated by chatgpt  ðŸ”Š', notificationFromDbForToday.length);

      /****************************************
      if(notificationFromDbForToday.length < 2){
          let newAIGeneratedNotification = await Notification.create({
              title: 'Hey! Donâ€™t forget to check your cycle insights today!',
              subTitle: 'Remainder',
              receiverId: req.user.userId,
              fromAi: false, 
          })

          console.log("newAIGeneratedNotification ðŸ’ŽðŸ’ŽðŸ’Ž", newAIGeneratedNotification);

          // await sendPushNotification(req.user.fcmToken, {
          //   title: 'Hey! Donâ€™t forget to check your cycle insights today!',
          //   content: 'Remainder',
          // }); 

      }
       *********************************** */

      // ðŸ’ŽðŸ’ŽðŸ’ŽðŸ’ŽðŸ’ŽðŸ’ŽðŸ’Ž it causes issue .. 
      // let allNotifications = await Notification.find({
      //   receiverId: req.user.userId,
      // }).updateMany(
      //   { $set: { viewStatus : true } },
      //   { new: true }
      // )


      // Step 1: Update only unread notifications
    const updateResult = await Notification.updateMany(
      { 
        receiverId: req.user.userId,
        viewStatus: { $ne: true } // not equal to true (covers false, null, undefined)
      },
      { 
        $set: { 
          viewStatus: true,
          readAt: new Date() // optional: track when it was read
        }
      }
    );

    // Step 2: Get all notifications (for display)
    const allNotifications = await Notification.find({
      receiverId: req.user.userId,
    })
    .sort({ createdAt: -1 })
    .limit(10);

    // Step 3: Optional - Get current unread count
    const remainingUnreadCount = await Notification.countDocuments({
      receiverId: req.user.userId,
      viewStatus: false
    });

      
      sendResponse(res, {
        code: StatusCodes.OK,
        data: allNotifications,// allNotifications,
        message: 'Todays notification already generated by chatgpt',
        success: true,
      });

      return;
    }

    console.log("ðŸ”Š Generate notification for today .. as no notification found for today as notificationFromDbForToday.length == ", notificationFromDbForToday.length)

    /************
     * 
     * No notification found for today, so we will generate it using chatgpt
     * 
     * ************** */

    // first we need to get the users current months all information .. 
    // like âš¡predictedPeriodStart âš¡ predictedPeriodEnd
    // âš¡ predictedOvulationDate âš¡ fertileWindow

    let data:any = await new FertieService().predictAllDates(req.user.userId);

    console.log("data ðŸ”Š", data);

    //  const [year, month] = req.body.date.split('-');
     const [year, month] = new Date().toISOString().split('T')[0].split('-');
    const targetYearMonth = `${year}-${month}`;

    // Find the month object that matches the target year-month
    const monthData = data.find(item => item.month === targetYearMonth);

    if (!monthData) {
      console.error(`No data found for month: ${targetYearMonth}`);
      return;
    }
     

    // Extract period start date for the found month
    const periodEvent : {
      predictedPeriodStart: Date;
      predictedPeriodEnd: Date;
      predictedOvulationDate: Date;
      fertileWindow: [Date, Date];
    } = monthData.events.find(event => event.predictedPeriodStart);
  
    console.log('periodEvent :::::::::::: ', periodEvent);

    
    // const periodStartDate = periodEvent.predictedPeriodStart//.split('T')[0];

    const user = await User.findById(req.user.userId).select(
      'personalize_Journey_Id'
    );
    if (!user) {
      console.error('User not found');
      return;
    }

    const journey = await PersonalizeJourney.findById(
            user?.personalize_Journey_Id
    );

    console.log('journey ðŸ”¥', journey);

    if (!journey) return;


    const { periodStartDate, periodLength, avgMenstrualCycleLength } =
        journey;

    const today = new Date();
    const baseDate = new Date(periodStartDate);

    let cycleDay = calculateCurrentCycleDay(
        today,
        baseDate,
        Number(avgMenstrualCycleLength)
    );

    console.log("cycleDay ðŸ”Š", cycleDay);
    /**
     * now we have information like 
     * periodEvent {
     *   predictedPeriodStart
     *   predictedPeriodEnd
     *   predictedOvulationDate 
     *   fertileWindow [ Date , Date ]
     * }
     * 
     * and cycleDay .. 
     */

    // Build system prompt
    const systemPrompt = `You are a friendly reproductive health assistant Named Fertie.
      Based on current months different dates like predictedPeriodStart, predictedPeriodEnd, 
      predictedOvulationDate, fertileWindow, cycleDay
      provide notification if current date matched with any of those date.

      Data available: 

      - PeriodStartDate: ${periodStartDate || 'N/A'}
      - PeriodEndDate: ${periodEvent.predictedPeriodEnd || 'N/A'}
      - predictedOvulationDate: ${periodEvent.predictedOvulationDate || 'N/A'}
      - fertileWindow: ${periodEvent.fertileWindow || 'N/A'}
      - cycleDay: ${cycleDay || 'N/A'}
      - currentDate: ${currentDate || 'N/A'} 

      -------------- Now generate notification title and subtitle .. if current date matched with any of those date --------------
  
      ---------------------------
      if any date matched give me notification response like {
        "title" : "notification title here!",
        "subTitle" : "notification subTitle here!",
      }

      -------------------------
      if no date matched give me response like {
        "title" : "Hey! Donâ€™t forget to check your cycle insights today!",
        "subTitle" : "Reminder",
      }

      Do not include \`\`\`json or \`\`\` or any other formatting. Return only the raw JSON object.
    `;
    ////////////////////////////////////////////////////

    // Initialize response string
        let responseText = '';
    
        // Retry logic for API rate limits
        const maxRetries = 3;
        let retries = 0;
        let delay = 1000; // Start with 1 second delay
        let stream;
    
        while (retries <= maxRetries) {
          try {
            stream = await model.chat.completions.create({
              model: 'gpt-4o', // qwen/qwen3-30b-a3b:free <- is give wrong result   // gpt-3.5-turbo <- give perfect result
              messages: [
                { role: 'system', content: systemPrompt },
                // { role: 'user', content: userMessage },
              ],
              temperature: 0.7,
              stream: true,
            });
    
            // If we get here, the request was successful
            break;
          } catch (error) {
            // Check if it's a rate limit error (429)
            if (error.status === 429) {
              if (
                error.message &&
                (error.message.includes('quota') ||
                  error.message.includes('billing'))
              ) {
                // This is a quota/billing issue - try fallback if we haven't already
                if (retries === 0) {
                  console.log('Quota or billing issue. Trying fallback model...');
                  try {
                    // Try a different model as fallback
                    stream = await model.chat.completions.create({
                      model: 'gpt-3.5-turbo', // Using the same model as a placeholder, replace with actual fallback
                      messages: [
                        { role: 'system', content: systemPrompt },
                        // { role: 'user', content: userMessage },
                      ],
                      temperature: 0.7,
                      stream: true,
                    });
                    break; // If fallback succeeds, exit the retry loop
                  } catch (fallbackError) {
                    console.error('Fallback model failed:', fallbackError);
                    // Continue with retries
                  }
                } else {
                  console.log(
                    'Quota or billing issue. No more fallbacks available.'
                  );
                  throw error; // Give up after fallback attempts
                }
              }
    
              // Regular rate limit - apply exponential backoff
              retries++;
              if (retries > maxRetries) {
                // Send error message to client before throwing
                res.write(
                  `data: ${JSON.stringify({
                    error: 'Rate limit exceeded. Please try again later.',
                  })}\n\n`
                );
                res.end();
                throw error; // Give up after max retries
              }
    
              console.log(
                `Rate limited. Retrying in ${delay}ms... (Attempt ${retries}/${maxRetries})`
              );
              await new Promise(resolve => setTimeout(resolve, delay));
    
              // Exponential backoff with jitter
              delay = delay * 2 * (0.5 + Math.random()); // Multiply by random factor between 1 and 1.5
            } else {
              // Not a rate limit error
              console.error('OpenAI API error:', error);
              res.write(
                `data: ${JSON.stringify({
                  error: 'An error occurred while processing your request.',
                })}\n\n`
              );
              res.end();
              return; // Exit the function
            }
          }
        }
    
        if (!stream) {
          res.write(
            `data: ${JSON.stringify({
              error: 'Failed to generate a response. Please try again.',
            })}\n\n`
          );
          res.end();
          return;
        }
    
        try {
            // Process each chunk as it arrives
     
          for await (const chunk of stream) {
            const content = chunk.choices[0]?.delta?.content || '';
            if (content) {
              responseText += content;
            }
          }
    
          // Parse the JSON string into an object
          let newAIGeneratedNotification;
          let allNotificaiton;
          let jsonResponse;
          try {
            // First, try to parse the response directly

            console.log("responseText ðŸŸ¢ðŸŸ¢ðŸŸ¢ :", responseText);
            
            jsonResponse = JSON.parse(responseText);

            console.log("jsonResponse ðŸŸ¢ðŸŸ¢ðŸŸ¢ :", jsonResponse);

            //-------------- we have to save this response to notification database .. 
                // and first we have to check if todays notification already generated or not
                // and if todays notification is not found in database .. then ai will generate new notification
                // for today and save it to database ..


            console.log("ðŸŸ¢ No AI Generated Notification found for today ... Lets generate ... ðŸ¤–");

            newAIGeneratedNotification = await Notification.create({
              title: jsonResponse.title,
              subTitle: jsonResponse.subTitle,
              receiverId: req.user.userId,
              fromAi: true, // Indicating this notification is generated by AI
            })

            //@ts-ignore
            // Emit to participant's personal room  .to(participantId) ðŸ”ŠðŸ”ŠðŸ”ŠðŸ”ŠðŸ”ŠðŸ”ŠðŸ”Š
            io.emit(`notification::${req.user.userId}`, {
              title: jsonResponse.title,
              subTitle: jsonResponse.subTitle,
              receiverId: req.user.userId,
              fromAi: true, 
            });

            /*************************************
             
            await sendPushNotification(req.user.fcmToken, {
              title: jsonResponse.title,
              content: jsonResponse.subTitle,
            });

             *********************************** */

            allNotificaiton = await Notification.find({
              receiverId: req.user.userId,
            }).sort({ createdAt: -1 }) // sort by createdAt descending
            .limit(10);

            console.log("jsonResponse ðŸŸ¢ðŸŸ¢ðŸŸ¢ :", jsonResponse);
          } catch (parseError) {
            // If direct parsing fails, try to extract JSON from the response
            console.log("ðŸ”´ðŸ”´ðŸ”´Failed to parse direct response, attempting to extract JSON");
            
            // Try to extract JSON using regex
            const jsonMatch = responseText.match(/\{[\s\S]*\}/);
            if (jsonMatch) {
              try {

                console.log("ðŸ”´ðŸ”´ðŸ”´Extracted JSON from response: jsonMatch[0] :: ", jsonMatch[0]);
                // ---------------------------------------------------------------------------------
                jsonResponse = JSON.parse(jsonMatch[0]); 

                //-------------- we have to save this response to notification database .. 
                // and first we have to check if todays notification already generated or not
                // and if todays notification is not found in database .. then ai will generate new notification
                // for today and save it to database ..


                console.log("ðŸŸ¢ No AI Generated Notification found for today ... Lets generate ... ðŸ¤–");

                newAIGeneratedNotification = await Notification.create({
                  title: jsonResponse.title,
                  subTitle: jsonResponse.subTitle,
                  receiverId: req.user.userId,
                  fromAi: true, // Indicating this notification is generated by AI
                })

                //@ts-ignore
                // Emit to participant's personal room  .to(participantId) ðŸ”ŠðŸ”ŠðŸ”ŠðŸ”ŠðŸ”ŠðŸ”ŠðŸ”Š
                io.emit(`notification::${req.user.userId}`, {
                  title: jsonResponse.title,
                  subTitle: jsonResponse.subTitle,
                  receiverId: req.user.userId,
                  fromAi: true, 
                });

                allNotificaiton = await Notification.find({
                  receiverId: req.user.userId,
                }).sort({ createdAt: -1 }) // sort by createdAt descending
                .limit(10);


                console.log("jsonResponse ðŸ”´ðŸ”´ðŸ”´ :", jsonResponse);

                //----------------------------------------------------------------------------------
              } catch (extractError) {
                console.error('Failed to extract valid JSON: extractError :: ðŸ”´ðŸ”´ðŸ”´', extractError);
                jsonResponse = {
                  suggestion: "Failed to parse AI response. Please try again. ðŸ”´ðŸ”´ðŸ”´",
                };
              }
            } else {
              // Fallback to a structured response if parsing fails
              jsonResponse = {
                suggestion: responseText.substring(0, 200) + "...",
                patternFertieNoticed: "Unable to parse the complete response",
                whatToKeepInMindInThisCycle: "Please try again later"
              };
            }
          }
         
          // Send end of stream marker
          // res.write(`data: ${JSON.stringify({ done: true, fullResponse: responseText })}\n\n `); // ðŸŸ¢
    
          sendResponse(res, {
            code: StatusCodes.OK,
            // jsonResponse,newAIGeneratedNotification,
             //data: {jsonResponse,newAIGeneratedNotification, allNotificaiton},  //   jsonResponse  //session.url,
            data: allNotificaiton ,
            message: `Notification generated successfully..`,
            success: true,
          });
    
          /**
           *
           * save bots response in the database ..
           */
    
          res.end(); // ðŸŸ¢ðŸŸ¢ðŸŸ¢ end korte hobe
        } catch (streamError) {
          console.error('Error processing stream:', streamError);
          res.write(
            `data: ${JSON.stringify({
              error: 'Stream processing error. Please try again.',
            })}\n\n`
          );
          res.end();
        }
  })

/*
const getAdminNotifications = catchAsync(async (req, res) => {
  const filters = pick(req.query, notificationFilters);
  const options = pick(req.query, ['sortBy', 'limit', 'page', 'populate']);
  const result = await NotificationService.getAdminNotifications(
    filters,
    options
  );
  sendResponse(res, {
    code: StatusCodes.OK,
    data: result,
    message: 'Admin Notifications fetched successfully',
  });
});

const getSingleNotification = catchAsync(async (req, res) => {
  const { id } = req.params;
  const result = await NotificationService.getSingleNotification(id);
  sendResponse(res, {
    code: StatusCodes.OK,
    data: result,
    message: 'Notification fetched successfully',
    success: true,
  });
});

const viewNotification = catchAsync(async (req, res) => {
  const { id } = req.params;
  const result = await NotificationService.viewNotification(id);
  sendResponse(res, {
    code: StatusCodes.OK,
    data: result,
    message: 'Notification viewed successfully',
    success: true,
  });
});

const deleteNotification = catchAsync(async (req, res) => {
  const { id } = req.params;
  await NotificationService.deleteNotification(id);
  sendResponse(res, {
    code: StatusCodes.OK,
    message: 'Notification deleted successfully',
    success: true,
    data: {},
  });
});

const clearAllNotification = catchAsync(async (req, res) => {
  const userId = req.user.userId;
  await NotificationService.clearAllNotification(userId);
  sendResponse(res, {
    code: StatusCodes.OK,
    message: 'All notifications cleared successfully',
    success: true,
    data: {},
  });
});

*/

export const NotificationController = {
  getALLNotification,
  getAllNotificationAlongWithTodaysNotificationGeneratedByChatGpt
  // getAdminNotifications,
  // getSingleNotification,
  // viewNotification,
  // deleteNotification,
  // clearAllNotification,
};

// Helper function to calculate current cycle day
function calculateCurrentCycleDay(
  currentDate: Date,
  baseDate: Date,
  avgCycleLength: number
): number {
  const daysSinceBase = Math.floor(
    (currentDate.getTime() - baseDate.getTime()) / (1000 * 60 * 60 * 24)
  );

  if (daysSinceBase < 0) {
    // Current date is before the base date
    return 1;
  }

  // Calculate which cycle we're in and what day of that cycle
  const cycleDay = (daysSinceBase % avgCycleLength) + 1;

  return cycleDay;
}